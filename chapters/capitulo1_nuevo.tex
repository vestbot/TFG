
%CAPITULO 1 NUEVO


%Añado el apartado de códigos lineales entero, sin embargo, como no vamos a usar los códigos duales, nos lo saltamos.

%Sobre el peso y las distancias, lo voy a añadir pero CAMBIAR la notación del peso a w en vez de wt

%Nos metemos ya en códigos cíclicos, mirar la parte de la factorización de x^n-1 de nuevo, pero lo de las clases q-ciclotómicas si lo voy a dejar tal cual.

%El punto de idempotentes me lo salto ya uqe no nos sirve, sobre los multiplicadores ya veré.

%Sobre los ceros, es importante lo del conjunto de definición.

% en Minima distancia de codigos ciclicos omito las otras técnicas de 
% acotación y dejamos solo la cota BCH que es la que nos interesa. Mirar también el ejemplo sobre la cota BCH

%Quitar en principio la nueva definición de los códigos Reed-Solomon en sentido estricto pero preguntarle a Gabriel si la dejo o no.


\chapter{Introducción a los códigos lineales}

Todo el desarrollo de este capítulo está basado en \cite{Huffman_Pless_2010} y \cite{Wassermann_2006} .
\section{Códigos lineales}

Sea $\mathbb{F}_q$ el cuerpo finito de $q$ elementos, denotamos, $\mathbb{F}_q^n$ al espacio vectorial de las n-tuplas sobre el cuerpo finito $\mathbb{F}_q$. A los vectores $(a_1,a_2,\cdots,a_n)$ de $\mathbb{F}_q$ generalmente los escribiremos como $a_1a_2\cdots a_n$.



\begin{definition}
Un $(n,M)$ \emph{código} $\mathcal{C}$ sobre $\mathbb{F}_q$ es un subconjunto de $\mathbb{F}_q^n$ de tamaño $M$. Llamaremos \emph{palabras código} a los elementos de $\mathcal{C}$.
\end{definition}

\begin{exampleth}
\begin{itemize}
	\item En el cuerpo $\mathbb{F}_2$, a los códigos se les conoce como \emph{códigos binarios} y un ejemplo sería $\mathcal{C} = \{00,01,10,11\}$

	\item En el cuerpo $\mathbb{F}_3$, a los códigos se les conoce como \emph{códigos ternarios} y un ejemplo sería $\mathcal{C} = \{01, 12, 02, 10, 20, 21, 22\}$
\end{itemize}
\end{exampleth}

Si $\mathcal{C}$ es un espacio k-dimensional de $\mathbb{F}_q^n$, entonces decimos que $\mathcal{C}$ es un $\left[n,k\right]$ \emph{código lineal} sobre $\mathbb{F}_q$ y tiene $q^k$ palabras código. Las dos formas más comunes de representar un código lineal son con la \emph{matriz generadora} o la \emph{matriz de paridad}.

\begin{definition}

Una \emph{matriz generadora} de un $\left[n,k\right]$ \emph{código lineal} $\mathcal{C}$ es cualquier matriz $k \times n$ cuyas filas forman una base de $\mathcal{C}$.
\end{definition}

Para cada conjunto de $k$ filas independientes de una matriz generadora $G$, se dice que dicho conjunto de coordenadas forman un \emph{conjunto de información} de $\mathcal{C}$. Las $r = n - k$ coordenadas restantes forman el \emph{conjunto de redundancia} y el número $r$ es la \emph{redundancia} de $\mathcal{C}$.

En general no hay una única matriz generadora pero si las primeras $k$ coordenadas forman un conjunto de información, entonces el código tiene una única matriz generado de la forma $\left[I_k | A\right]$, donde $I_k$ es la matriz identidad $k \times k$. Esta matriz se dice que está en \emph{forma estándar}.

Como un código lineal es un subespacio de un espacio vectorial, es el núcleo de alguna transformación lineal.

\begin{definition}
Una \emph{matriz de paridad} $H$ de dimensión $(n-k) \times k$ es una matriz que verifica que %de un $\left[n,k\right]$ \emph{código lineal} $\mathcal{C}$ es una matriz que verifica :
\[
C = \{ x \in  \mathbb{F}_q^n | Hx^T = 0  \}
\]
\end{definition}

Como ocurría con la matriz generadora, la matriz de paridad no es única. Con el siguiente resultado podremos obtener una de ellas cuando $\mathcal{C}$ tiene una matriz generadora en forma estándar.

\begin{theorem}[Matriz de paridad a partir de la generadora]
\label{th:matriz_paridad}

Si $G = \left[I_k | A\right]$ es una matriz generadora del $\left[n,k\right]$ código $\mathcal{C}$ en su forma estándar, entonces $H = \left[-A^T |I_{n-k}\right]$ es la matriz de paridad de $\mathcal{C}$.
\end{theorem}

\begin{proof}
Sabemos que $HG^T = -A^T + A^T = 0$, luego $\mathcal{C}$ está contenido en el núcleo de la transformación lineal $x \mapsto Hx^T$. Como $H$ tiene rango $n-k$, el núcleo de esta transformación es de dimensión $k$ que coincide con la dimensión de $\mathcal{C}$.
\end{proof}

\begin{exampleth}
 \label{ex:matriz_generadora}
Sea la matriz $G = \left[I_4 | A\right]$, donde

\[
G = \left( \begin{array}{cccc|ccc}
	1 & 0 & 0 & 0 & 0 & 1 & 1 \\
	0 & 1 & 0 & 0 & 1 & 0 & 1 \\
	0 & 0 & 1 & 0 & 1 & 1 & 0 \\
	0 & 0 & 0 & 1 & 1 & 1 & 1 
			\end{array} 
	\right)
\]
es la matriz generadora en forma estándar del $\left[7,4\right]$ código binario que denotaremos por $\mathcal{H}_3$.
Por el Teorema \ref{th:matriz_paridad}, la matriz de paridad de $\mathcal{H}_3$ es

\[
H =  \left[A^T | I_3\right] = \left( \begin{array}{cccc|ccc}
	0 & 1 & 1 & 1 & 1 & 0 & 0 \\
	1 & 0 & 1 & 1 & 0 & 1 & 0 \\
	1 & 1 & 0 & 1 & 0 & 0 & 1 

			\end{array} 
	\right)
\]

Este código se le conoce como el $\left[7,4\right]$ \emph{código de Hamming}.
\end{exampleth}

\section{Pesos y distancias}
\begin{definition}
La \textit{distancia de Hamming} $d(x,y)$ entre dos vectores $x,y \in \mathbb{F}_q^n$ es el número de coordenadas en las que x e y difieren. 
\end{definition}

\begin{exampleth}
	Sea $\mathbf{x}=20110$ y $\mathbf{y}=10121$ entonces $d(x,y)=3$.
\end{exampleth}

%TODO cambiar el teorema por La distancia de Hamming es una distancia en \mathbb{F}_q^n
% y ya en la demostración decir que cumple las 4 propiedades.
\begin{theorem}
	La distancia de Hamming $d(x,y)$ satisface las siguientes cuatro propiedades:
	\begin{enumerate}
	\item No negatividad: $d(x,y) \geq 0 \quad \forall x,y \in \mathbb{F}_q^n$.
	\item $d(x,y)=0 \Leftrightarrow x = y$.
	\item Simetría: $d(x,y)=d(y,x) \quad \forall x,y \in \mathbb{F}_q^n$.
	\item Desigualdad triangular: $d(x,z)\leq d(x,y) + d(y,z) \quad \forall x,y,z \in \mathbb{F}_q^n$.
	\end{enumerate}
	
\end{theorem}

\begin{proof}
Las tres primeras propiedades son evidentes por la definición de la distancia, comprobemos la última propiedad.

Distinguimos dos casos, si $ x = z $ tenemos que $d(x,z) = 0$ y por tanto se verifica la desigualdad. Si $x \neq z$ entonces, no puede ocurrir que $x = y = z $, por tanto $d(x,y) \neq 0$ o $d(y,z) \neq 0$ y por la no negatividad se tendría la desigualdad, en el caso de que $ x = y$ o $y = z$ tendríamos la igualdad.
\end{proof}

Llamaremos \textbf{distancia mínima} de un código $\mathcal{C}$ a la menor distancia entre dos palabras del código. Además, esta distancia es un invariante y es importante a la hora de determinar la capacidad de corrección de errores del código $\mathcal{C}$ .

\begin{exampleth}
Sea $\mathcal{C} = \left\{ 201310, 311210, 202210, 312100 \right\} $ un código. Sus distancias son:
\[
d(201310, 311210) = 3 , \quad d(201310,202210) = 2, \quad d(201310,312100) = 5,
\]
\[
 d(311210, 202210) = 3, \quad d(311210,312100) = 3, \quad d(202210,312100) = 4 
\]
Luego, la distancia mínima es $d(\mathcal{C}) = 2$.
\end{exampleth}

\begin{definition}
El \textbf{peso de Hamming}, denotado por $\operatorname{wt}(x)$, de un vector $x \in \mathbb{F}_q^n$ es el número de coordenadas no-nulas en $x$. Llamaremos \textit{peso de $\mathcal{C}$} a 
$\operatorname{wt}(\mathcal{C}) = \min(\operatorname{wt}(x))$ con $x \neq 0 $.
\end{definition}

\begin{exampleth}
	Sea $\mathbf{x} = 202210$ un vector en $\mathbb{F}_3^6$ entonces $\operatorname{wt}(x) = 4$.
\end{exampleth}

\begin{theorem}
Si $x,y \in \mathbb{F}_q^n$, entonces $d(x,y) = \operatorname{wt}(x-y)$. Si $\mathcal{C}$ es un código lineal, la distancia mínima $d$ es igual al peso mínimo de $\mathcal{C}$.
\end{theorem}

\begin{proof}
Como $\mathcal{C}$ es lineal, tenemos que $ 0 \in \mathcal{C}$ y además $\operatorname{wt}(x) = d(x,0) \quad \forall x \in \mathcal{C}$, luego $d(\mathcal{C}) \leq \operatorname{wt}(\mathcal{C})$.

Por otro lado, sea $x,y \in \mathcal{C}$ entonces $x-y \in \mathcal{C} \quad \forall x,y \in \mathcal{C}$ y sabemos que $d(x,y) = \operatorname{wt}(x-y) \geq \operatorname{wt}(\mathcal{C})$ para cualesquiera $x,y \in \mathcal{C}$. Se tiene que $d(\mathcal{C}) \geq \operatorname{wt}(\mathcal{C})$.

Hemos conseguido así la igualdad, $d(\mathcal{C}) = \operatorname{wt}(\mathcal{C})$.
\end{proof}

Como resultado de este teorema, para códigos lineales, la \textbf{ distancia mínima}  también se denomina el \textbf{peso mínimo} de un código. Si se conoce el peso mínimo de un código entonces nos referiremos a él como el $\left[n,k,d\right]$ código.


\section{Códigos cíclicos}

Vamos a estudiar los códigos cíclicos de longitud n, por ello, denotaremos las coordenadas de sus posiciones como $0,\cdots,n-1$ que son los enteros módulo n.

\begin{definition}
 Un código lineal $\mathcal{C}$ de longitud n sobre $\mathbb{F}_q$ es \textit{cíclico} si para cada vector $c = c_0\cdots c_{n-2}c_{n-1}$ en  $\mathcal{C}$, el vector $c_{n-1},c_0,\cdots,c_{n-2}$ obtenido de \textbf{c} por la permutación de las coordenadas $ i \rightarrow i+1 (\thinspace mod \thinspace n)$, está también en $\mathcal{C}$.
 \end{definition}
 
 Así, un código cíclico contiene las n permutaciones cíclicas de cada palabra código. Por tanto, es conveniente pensar que las coordenadas cuando alcanzan $n-1$, vuelven a la coordenada $0$.

Cuando hablemos de códigos cíclicos sobre $\mathbb{F}_q$, normalmente las palabras códigos las representaremos en su forma polinómica, ya que hay un isomorfismo de $\mathbb{F}_q$-espacios vectoriales entre los vectores $c = c_0c_1\cdots c_{n-1}$ en $\mathbb{F}_q^n$ y los polinomios $c(x)=c_0+c_1x+\cdots+c_{n-1}x^{n-1}$ en $\mathbb{F}_q[x]$ con grado como mucho $n-1$. Notemos que si \textbf{c} es el polinomio dado, entonces $xc(x)=c_{n-1}x^{n}+c_0x+c_1x^2+\cdots+c_{n-2}x^{n-1}$ representa una permutación de \textbf{c} si $x^n$ es igual a $1$. Más formalmente, el hecho de que el código cíclico $\mathcal{C}$ sea invariante por permutaciones, implica que, $c(x)$ está en $\mathcal{C}$, entonces $xc(x)$ también lo está. 

Esto sugiere que para un mejor estudio de los códigos cíclicos, desarrollemos el anillo cociente \[ \mathcal{R}_n =\mathbb{F}_q[x] / (x^n-1).\] Bajo la correspondencia vectores-polinomios dada anteriormente, los códigos cíclicos son ideales de $\mathcal{R}_n$ y los ideales de $\mathcal{R}_n$ son códigos cíclicos. Luego, el estudio de códigos cíclicos en $\mathbb{F}_q^n$ es equivalente al estudio de los ideales de $\mathcal{R}_n$. Para este estudio necesitamos factorizar el polinomio $x^n-1$.

\subsection{Factorización de $x^n-1$ }
Queremos encontrar los factores irreducibles de $x^n-1$. Encontramos dos posibilidades: que $x^n-1$ tenga factores irreducibles repetidos o no los tenga. En el caso de los códigos cíclicos, se centra más en el segundo caso ya que en el primero, las capacidades de correción son peores por lo que no es tan interesante, por ello, hacemos la asumpción de que $x^n-1$ no tiene factores repetidos, que es equivalente a que \textit{q} y \textit{n} son primos relativos.

Como ayuda para factorizar $x^n-1$ sobre $\mathbb{F}_q^n$, es útil considerar la extensión $\mathbb{F}_{q^t}^n$ sobre $\mathbb{F}_q^n$ que contiene todas las raíces del polinomio. En otras palabras, $\mathbb{F}_{q^t}^n$ debe contener las raíces primitivas \textit{n-ésimas} de la unidad, que ocurre cuando $ n \mid (q^t-1)$.  Definimos el orden, $ord_n(q)$ de \textit{q} módulo \textit{n}, como el entero positivo más pequeño \textit{a} tal que $q^a \equiv 1 \thinspace ( mod \thinspace n)$. Notemos que si $t = ord_n(q)$, entonces $\mathbb{F}_{q^t}^n$ contiene la raíz primitiva \textit{n-ésima} de la unidad $\alpha$ , pero ninguna extesión del cuerpo $\mathbb{F}_q^n$ contiene esa raíz. Como los $\alpha^i$ son distintos para $0 \leq i < n $ y $(\alpha^i)^n = 1$ , entonces $\mathbb{F}_{q^t}^n$ contiene todas las raíces de $x^n-1$. Consecuentemente, llamaremos a $\mathbb{F}_{q^t}^n$ el \textit{cuerpo de descomposición} de $x^n-1$ sobre $\mathbb{F}_q^n$. Así que los factores irreducibles de $x^n-1$ sobre $\mathbb{F}_q^n$ deben de ser productos de los distintos polinomios mínimos de las raíces \textit{n-ésimas} en $\mathbb{F}_{q^t}^n$.  Supongamos que $\gamma$ es un elemento primitivo, es decir, el elemento generador de $\mathbb{F}_{q^t}^n$, entonces $\alpha = \gamma^d$ es una raíz primitiva \textit{n-ésima} de la unidad en donde $d = (q^t-1)/n$. Las raíces de $\mathcal{M}_{\alpha^s}(x)$ son $\{ \gamma^{ds}, \gamma^{dsq},\gamma^{dsq^2} ,\cdots, \gamma^{dsq^{r-1}} \} = \{ \alpha^s,\alpha^{sq},\alpha^{sq^2},\cdots,\alpha^{sq^{r-1}} \}$ donde \textit{r} es el entero positivo más pequeño que cumple que $dsq^r \equiv ds \thinspace ( mod \thinspace q-1 )$ pero esto se verifica si y solo si $sq^r \equiv s \thinspace ( mod \thinspace n )$


\begin{definition}
Sea $\mathbb{F}_q^n$ un cuerpo finito y $\mathbb{F}_{q^t}^n$ una extensión de $\mathbb{F}_q^n$, llamaremos \textit{clase q-ciclotómica de s módulo n} al conjunto :
\[
	\mathcal{C}_s = \{s,sq,\cdots,sq^{r-1} \} \thinspace (mod \thinspace n)
\]
donde \textit{r} es el menor entero positivo tal que $sq^r \equiv s \thinspace (mod \thinspace n ) $.
\end{definition}

Las distintas clases \textit{q-ciclotómicas} modulo \textit{n} forman una partición del conjunto de los enteros $\{0,1,2,\cdots,n-1\}$.

\begin{exampleth}
\label{ex: clase_mod_quince}
 Vamos a calcular las clases \textit{2-ciclotómicas} para $n=21$ y $q=2$ :

La primera de todas es $\mathcal{C}_0 = \{ 0*2^r \equiv 0 \thinspace (mod \thinspace 21) \} = \{ 0 \} $ y repetimos este proceso. Luego tenemos:

$\mathcal{C}_1 = \{ 1*2^r \equiv 1 \thinspace (mod \thinspace 21) \} = \{ 1, 1*2^1=2, 1*2^2 = 4, 1*2^3 = 8, 1*2^4 = 16,1*2^5 = 11 \} = \{1,2,4,8,11,16\} $
ya que $1*2^6 = 64 \equiv 1 \thinspace (mod \thinspace 21)$ luego $r=6$.

$\mathcal{C}_3 = \{ 3*2^r \equiv 3 \thinspace (mod \thinspace 21) \} = \{ 3,3*2 = 6, 3*2^2 = 12\} = \{3,6,12 \} $ ya que $3*2^3 = 24 \equiv 3 \thinspace (mod \thinspace 21 )$ luego $r=3$.

$\mathcal{C}_5 = \{ 5*2^r \equiv 5 \thinspace (mod \thinspace 21) \} = \{ 5, 5*2=10,5*2^2 = 20, 5*2^3 = 19, 5*2^4 = 17,5*2^5 = 13 \} = \{5,10,13,17,19,20\} $
ya que $5*2^6 = 320 \equiv 5 \thinspace (mod \thinspace 21)$ luego $r=6$.

$\mathcal{C}_7 = \{ 7*2^r \equiv 7 \thinspace (mod \thinspace 21) \} = \{ 7,7*2 = 14 \} = \{ 7,14 \} $ ya que $7*2^2 = 28 \equiv 7 \thinspace (mod \thinspace 21 )$ luego $r=2$.

$\mathcal{C}_9 = \{ 9*2^r \equiv 9 \thinspace (mod \thinspace 21) \} = \{ 9,9*2 = 18,9*2^2 = 15 \} = \{ 9,15,18 \} $ ya que $9*2^3 = 72 \equiv 9 \thinspace (mod \thinspace 21 )$ luego $r=3$.

\end{exampleth}

\begin{exampleth} 
\label{ex:clase_mod_ocho}
Vamos a calcular las clases \textit{3-ciclotómicas} para $n=8$ y $q=3$ que serán las siguientes :

$\mathcal{C}_0 = \{ 0*3^r \equiv 0 \thinspace (mod \thinspace 8) \} = \{ 0 \} $

$\mathcal{C}_1 = \{ 1*3^r \equiv 1 \thinspace (mod \thinspace 8) \} = \{ 1, 1*3^1=3 \} = \{1,3\} $
ya que $1*3^2 = 9 \equiv 1 \thinspace (mod \thinspace 8)$ luego $r=2$.

$\mathcal{C}_2 = \{ 2*3^r \equiv 2 \thinspace (mod \thinspace 8) \} = \{ 2, 2*3^1=6 \} = \{2,6\} $
ya que $2*3^2 = 18 \equiv 2 \thinspace (mod \thinspace 8)$ luego $r=2$.

$\mathcal{C}_4 = \{ 4*3^r \equiv 4 \thinspace (mod \thinspace 8) \} = \{ 4 \} $
ya que $4*3^1 = 12 \equiv 4 \thinspace (mod \thinspace 8)$ luego $r=1$.

$\mathcal{C}_5 = \{ 5*3^r \equiv 5 \thinspace (mod \thinspace 8) \} = \{ 5, 5*3^1=7 \} = \{5,7\} $
ya que $5*3^2 = 45 \equiv 5 \thinspace (mod \thinspace 8)$ luego $r=2$.

Luego, ya tenemos todas las clases \textit{3-ciclotómicas} para $n=8$ y $q=3$.

\end{exampleth}



\begin{theorem}
\label{th:factorizar_xn}
Sea \textit{n} un entero positivo, primo relativo con \textit{q}. Sea $t = ord_n(q)$ y sea $\alpha$ la raíz primitiva \textit{n-ésima} de la unidad en $\mathbb{F}_{q^t}$.
\begin{enumerate}

	\item Por cada entero \textit{s} con $0 \leq s < n$, el polinomio mínimo de $\alpha^s$ sobre  $\mathbb{F}_q$ es
	\[
	\mathcal{M}_{\alpha^s}(x) = \prod_{i \in \mathcal{C}_s} (x-\alpha^i)
	\] 
	donde $\mathcal{C}_s$ es la clase \textit{q-ciclotómica} de \textit{s} módulo \textit{n}.
	\item  Los conjugados de $\alpha^s$ son los elementos $\alpha^i$ con $i \in \mathcal{C}_s$.
	\item  
	\[
	x^n-1 =  \prod_{s} \mathcal{M}_{\alpha^s}(x) 
	\]
	es la factorización de $x^n-1$ en factores irreducibles sobre $\mathbb{F}_q$ donde \textit{s} recorre un conjunto de los representantes de la clase \textit{q-ciclotómica} modulo \textit{n}.
\end{enumerate}
\end{theorem}
 
\begin{proof}
    1) Queremos encontrar el polinomio mínimo de $\alpha^s$ sobre $\mathbb{F}_q$. Recordemos que si $i \in \mathcal{C}_s$ quiere decir que $ i \equiv s \thinspace (s \thinspace mod \thinspace n)$. Vamos a demostrar que $\mathcal{M}_{\alpha^s}(\alpha^s) = 0$ y que $\mathcal{M}_{\alpha^s}(x)$ es irreducible en $\mathbb{F}_q$.

    Si evaluamos $\mathcal{M}_{\alpha^s}(x)$ en $\alpha^s$ obtenemos
    \[ \mathcal{M}_{\alpha^s}(\alpha^s) = \prod_{i \in \mathcal{C}_s} (\alpha^s-\alpha^i)\]
Como $\alpha^i$ es una potencia de $\alpha$, es raíz $n$-ésima de la unidad y podemos reescribir la expresión anterior como 
\begin{eqnarray*}
    \mathcal{M}_{\alpha^s}(\alpha^s) & = & \prod_{i \in \mathcal{C}_s} (\alpha^s-\alpha^i) \\
    & = &  \prod_{i \in \mathcal{C}_s} (\alpha^s-(\alpha^s)^i) \\
    & = &   \prod_{i \in \mathcal{C}_s} (\alpha^s-\alpha^{si}) \\
    & = &  \prod_{i \in \mathcal{C}_s} (\alpha^s-\alpha^s) \\
    & = &  \prod_{i \in \mathcal{C}_s} (0) = 0
\end{eqnarray*}

Ahora, para ver que $\mathcal{M}_{\alpha^s}(x)$ es irreducible, sabemos que los $\alpha^i$ con $ i \in \mathcal{C}_s$ son distintos, luego $(x-\alpha^i)$ son también distintos. Por esta razón, $\mathcal{M}_{\alpha^s}(x)$ no se puede factorizar más y obtenemos que es el polinomio mínimo.

Para demostrar 2), por definición de conjugado, los conjugados de $\alpha^s$ tienen el mismo polinomio mínimo que $\alpha^s$ y por 1) sabemos cual es el polinomio mínimo de $\alpha^s$. Por consiguiente, los conjugados son justo los $\alpha^i$ con $ i \in \mathcal{C}_s$.

Para 3), para el conjunto de representantes de la clase $q$-ciclotómica modulo n sabemos que, por 1), cada $s$ tiene un polinomio mínimo distinto y además que $\alpha^s$ es raíz de $\mathcal{M}_{\alpha^s}(x)$. Luego, podemos escribir $x^n-1$ como producto de polinomios mínimos de la siguiente forma

\[ x^n-1 =  \prod_{s} \mathcal{M}_{\alpha^s}(x) .\]

Como hemos visto en 1) los $\mathcal{M}_{\alpha^s}(x)$ son irreducibles en $\mathbb{F}_q$ así que hemos terminado la demostración.
\end{proof}
 \begin{exampleth}
Vamos a factorizar $x^{15}-1$ para ello, calculamos las clases \textit{2-ciclotómicas} que son $\mathcal{C}_0 = \{ 0 \}$ , $\mathcal{C}_1 = \{ 1,2,4,8 \}$, $\mathcal{C}_3 = \{ 3,6,9,12 \}$, $\mathcal{C}_5 = \{ 5,10 \}$ y $\mathcal{C}_7 = \{ 7,11,13,14 \}$. Siendo un conjunto de representantes $\{ 0,1,3,5,7 \}$. Luego el $ord_{15}(2) = 4$ y la  raíz primitiva \textit{quince-ésima} de la unidad reside en la extensión $\mathbb{F}_{16}$ .


Podemos afirmar que los factores irreducibles de $x^{15}-1$ tienen grado 1,4,4,2 y 4. Estos polinomios son $\mathcal{M}_{1}(x) = x+1 $ , $\mathcal{M}_{\alpha}(x)$, $\mathcal{M}_{\alpha^3}(x)$, $\mathcal{M}_{\alpha^5}(x)$ y $\mathcal{M}_{\alpha^7}(x)$ donde $\alpha$ es la raíz primitiva \textit{quince-ésima} de la unidad en $\mathbb{F}_{16}$. Como el único polinomio irreducible de grado dos en $\mathbb{F}_2$ es $x^2+x+1$ no queda otra que sea $\mathcal{M}_{\alpha^5}(x)$.  Usando la raíz primitiva \textit{quince-ésima} de la unidad $\alpha$ y que $x^4 + x +1$ es irreducible en $\mathbb{F}_2$ ya que $x^2+x+1$ no es un factor suyo y $x+1$ tampoco, podemos obtener la siguiente tabla,

\begin{table}[H]
\begin{tabular}{ c | c | c | c | c | c | c | c }

	 
$0000$ & $0$  & $1000$ & $\alpha^3$ & $1011$ & $\alpha^7$ & $1110$ & $\alpha^{11}$ \\$0001$ & $1$  & $0011$ & $\alpha^4$ & $0101$ & $\alpha^8$ & $1111$ & $\alpha^{12}$ \\
$0010$ & $\alpha$  & $0110$ & $\alpha^5$ & $1010$ & $\alpha^9$ & $1101$ & $\alpha^{13}$ \\
$0100$ & $\alpha^2$  & $1100$ & $\alpha^6$ & $0111$ & $\alpha^{10}$ & $1001$ & $\alpha^{14}$ \\
	\end{tabular}
\caption{$\mathbb{F}_{16}$ con elemento primitivo $\alpha$ donde $\alpha^4 = \alpha +1$}
\end{table}
 
Aplicamos el Teorema \ref{th:factorizar_xn} para obtener el resto de factores de $x^{15}-1$.

\[ x^{15}-1 = \mathcal{M}_{1}(x) \mathcal{M}_{\alpha}(x) \mathcal{M}_{\alpha^3}(x) \mathcal{M}_{\alpha^5}(x) \mathcal{M}_{\alpha^7}(x). \]
 
 Calculamos $ \mathcal{M}_{\alpha}(x)$,$ \mathcal{M}_{\alpha^3}(x)$ y $ \mathcal{M}_{\alpha^7}(x)$ :
 
 \begin{equation*}
 \begin{split}
 \mathcal{M}_{\alpha}(x) & = (x-\alpha)(x-\alpha^2)(x-\alpha^4)(x-\alpha^8) \\
   & = (x^2 + \alpha^2 x + \alpha x + \alpha^3)(x^2 + \alpha^8 x + \alpha^4 x + \alpha^{12}) \\
  & = (x^2+(\alpha^2 + \alpha) x + \alpha^3)(x^2+(\alpha^2 + \alpha)x + \alpha^{12})  \\
   & = x^4 + (\alpha^2 + \alpha + \alpha^2 + \alpha)x^3 + (\alpha^{12} + \alpha^4 + \alpha^2 + \alpha^3 )x^2 + (\alpha^{14} + \alpha^{13} + \alpha^5 + \alpha^4)x + 1 \\
  & = x^4 + x + 1
 \end{split}
 \end{equation*}
 
 \begin{equation*}
 \begin{split}
 \mathcal{M}_{\alpha^3}(x) & = (x-\alpha^3)(x-\alpha^6)(x-\alpha^9)(x-\alpha^{12}) \\
   & = (x^2 + \alpha^6 x + \alpha^3 x + \alpha^9)(x^2 + \alpha^{12} x + \alpha^9 x + \alpha^6) \\
  & = (x^2+\alpha^2 x + \alpha^9)(x^2+(\alpha^2+1)x + \alpha^6)  \\
   & = x^4 + (\alpha^2 + 1 + \alpha^2)x^3 + (\alpha^6 + \alpha^4 + \alpha^2 + \alpha^9 )x^2 + (\alpha^8 + \alpha^{11} + \alpha^9)x + 1 \\
  & = x^4 + x^3 + x^2 + x + 1
 \end{split}
 \end{equation*}
 
 \begin{equation*}
 \begin{split}
 \mathcal{M}_{\alpha^7}(x) & = (x-\alpha^7)(x-\alpha^{11})(x-\alpha^{13})(x-\alpha^{14}) \\
   & = (x^2 + \alpha^7 x + \alpha^{11} x + \alpha^3)(x^2 + \alpha^{13} x + \alpha^{14} x + \alpha^{12}) \\
  & = (x^2+(\alpha^2+1) x + \alpha^3)(x^2+\alpha^2 x + \alpha^{12})  \\
   & = x^4 + (\alpha^2 + \alpha^2 + 1)x^3 + (\alpha^{12} + \alpha^4 + \alpha^2 + \alpha^3 )x^2 + (\alpha^{14} + \alpha^{12} + \alpha^5)x + 1 \\
  & = x^4 + x^3 + 1
 \end{split}
 \end{equation*}

Por tanto, podemos concluir que la factorización de $x^{15}-1$ es 


\[ 
x^{15}-1=(x+1)(x^4+x+1)(x^4+x^3+x^2+x+1)(x^2+x+1)(x^4+x^3+1)
\] 
  

 \end{exampleth}
 
\begin{exampleth}
Ahora vamos a factorizar $x^8-1$ para ello, cogemos las clases \textit{3-ciclotómicas} calculadas en el Ejemplo \ref{ex:clase_mod_ocho} que son $\mathcal{C}_0 = \{ 0 \}$ , $\mathcal{C}_1 = \{ 1,3 \}$, $\mathcal{C}_2 = \{ 2,6 \}$,  $\mathcal{C}_4 = \{ 4 \}$ y  $\mathcal{C}_5 = \{ 5,7 \}$ .Siendo un conjunto de representantes $\{ 0,1,2,4,5 \}$. Luego el $ord_8(3) = 2$ y la raíz primitiva \textit{ocho-ésima} de la unidad reside en la extensión $\mathbb{F}_{9}$.

Podemos afirmar que los factores irreducibles de $x^8-1$ tienen grado 1,2,2,1 y 2. Estos polinomios son $\mathcal{M}_{1}(x)$ , $\mathcal{M}_{\alpha}(x)$, $\mathcal{M}_{\alpha^2}(x)$,  $\mathcal{M}_{\alpha^4}(x)$ y  $\mathcal{M}_{\alpha^5}(x)$ donde $\alpha$ es la  raíz primitiva \textit{ocho-ésima} de la unidad en $\mathbb{F}_{9}$. Usando la raíz primitiva \textit{ocho-ésima} de la unidad $\alpha$ y que $x^2 + x +1$ es irreducible en $\mathbb{F}_3$ ya que $x+2$ no es un factor suyo y $x+1$ tampoco, podemos obtener la siguiente tabla,

\begin{table}[H]
\begin{tabular}{ c | c | c | c | c | c | }

	 
$00$ & $0$  & $21$ & $\alpha^3$ & $12$ & $\alpha^7$  \\
$01$ & $1$  & $02$ & $\alpha^4$   \\
$10$ & $\alpha$  & $20$ & $\alpha^5$    \\
$11$ & $\alpha^2$  & $22$ & $\alpha^6$  \\
	\end{tabular}
\caption{$\mathbb{F}_{9}$ con elemento primitivo $\alpha$ donde $\alpha^2 = \alpha +1$}
\end{table}

Aplicamos el Teorema \ref{th:factorizar_xn} para obtener los factores de $x^8-1$.

\[ x^8-1 = \mathcal{M}_{1}(x) \mathcal{M}_{\alpha}(x) \mathcal{M}_{\alpha^2}(x) \mathcal{M}_{\alpha^4}(x) \mathcal{M}_{\alpha^5}(x). \]



\begin{equation*}
 \mathcal{M}_1(x)  = (x-1) = x+2 
\end{equation*}
 
 \begin{equation*}
 \begin{split}
 \mathcal{M}_{\alpha}(x) & = (x-\alpha)(x-\alpha^3) \\
 	& = x^2 -\alpha x - \alpha^3 x + \alpha^4 \\
 	& = x^2 - (\alpha + \alpha^3)x + 2 \\
 	& = x^2 + 2x + 2
 \end{split}
 \end{equation*}
 
 \begin{equation*}
 \begin{split}
 \mathcal{M}_{\alpha^2}(x) & = (x-\alpha^2)(x-\alpha^6)  \\
 	& = x^2 -\alpha^2 x - \alpha^6 x + 1 \\
 	& = x^2 - (\alpha^2 + \alpha^6)x + 1 \\
 	& = x^2 + 1
 \end{split}
 \end{equation*}
 
 \begin{equation*}
 \mathcal{M}_{\alpha^4}(x)  = (x-\alpha^4) = x - 2 = x + 1
 \end{equation*}
 
 \begin{equation*}
 \begin{split}
 \mathcal{M}_{\alpha^5}(x) & = (x-\alpha^5)(x-\alpha^7)  \\
 	& = x^2 -\alpha^5 x - \alpha^7 x + \alpha^4 \\
 	& = x^2 - (\alpha^5 + \alpha^7)x + 2 \\
 	& = x^2 + x + 2
 \end{split}
 \end{equation*}
 
 Por tanto, podemos concluir que la factorización de $x^8-1$ es 


\[ 
x^8-1=(x+2)(x^2+2x+2)(x^2+1)(x+1)(x^2+x+2)
\] 
 
\end{exampleth}
 
Viendo estos ejemplos podemos deducir que el tamaño de cada clase \textit{q-ciclotómica} es un divisor del $ord_n(q)$.

\begin{theorem}
\label{th:tamaño_ciclotomicos}
El tamaño de cada clase \textit{q-ciclotómica} es un divisor del $ord_n(q)$. Además, el tamaño de $\mathcal{C}_1$ es justamente el  $ord_n(q)$.
\end{theorem}

\begin{proof}
Sea $t = ord_n(q)$ y sea $m$ el tamaño de $\mathcal{C}_s$. Entonces $\mathcal{M}_{\alpha^s}(x)$ es un polinomio de grado m donde $\alpha$ es la \textit{n-ésima} raíz primitiva de la unidad. Así que, $ m \mid t$. Por definición de orden y clase \textit{q-ciclotómica} sale que el tamaño de $\mathcal{C}_1 = ord_n(q) $.
\end{proof}


\subsection{Teoría básica de los códigos cíclicos}

Anteriormente, comentábamos que los códigos cíclicos sobre $\mathbb{F}_q$ son precisamente los ideales de 
\[
\mathcal{R}_n = F_q[x]/(x^n-1).
\]
Además, cada ideal de $\mathbb{F}_q[x]$ es un ideal principal, luego los ideales de $\mathcal{R}_n$ son también principales y por eso, los códigos cíclicos son ideales principales de $\mathcal{R}_n$.

Los elementos de $\mathcal{R}_n$ son polinomios de $\mathbb{F}_q$ con grado menor que n y el producto lo realizamos módulo $x^n-1$. Así, cuando trabajamos en $\mathcal{R}_n$, al multiplicar dos polinomios,  lo hacemos como en $\mathbb{F}_q[x]$ y reemplazamos los términos de la forma $ax^{ni+j}$, con $ 0 \leq j < n$ por $ax^j$.

Para distinguir el ideal principal $(g(x))$ de $\mathbb{F}_q[x]$ del ideal principal de $\mathcal{R}_n$, denotamos $<g(x)>$ como el ideal principal de $\mathcal{R}_n$ generado por $g(x)$. Vemos ahora con el siguiente teorema que hay una correspondencia biyectiva entre los códigos cíclicos en $\mathcal{R}_n$ y los polinomios mónicos divisores de $x^n-1$.


\begin{theorem}
\label{th:base_ciclicos}
Sea $\mathcal{C} $ un código cíclico no nulo en $\mathcal{R}_n$. Existe un polinomio $g(x) \in \mathcal{C}$ que cumple las siguientes propiedades:
\begin{enumerate}
	\item $g(x)$ es el polinomio mónico de menor grado en $\mathcal{C}$.
	\item $\mathcal{C} = <g(x)>$.
	\item $g(x) | (x^n-1)$.
	
	Sea $k = n - deg(g(x))$ y sea $g(x) = \sum_{i=0}^{n-k}g_ix^i$ donde $g_{n-k} = 1$. Entonces:
	\item La dimensión de $\mathcal{C}$ es k y $\{g(x),xg(x),\cdots,x^{k-1}g(x)\}$ forman una base de $\mathcal{C}$.
	\item Cada elemento de $\mathcal{C}$ se puede expresar como el producto de $g(x)f(x)$, donde $f(x) = 0$ o $deg(f(x)) < k$.
	\item 	
	
	$\mathcal{G} = \begin{pmatrix}
			g_0 & g_1 & g_2 & \cdots & g_{n-k} & 0 & \cdots & 0 \\
			0 & g_0 & g_1 & g_2 & \cdots & g_{n-k} & \cdots & \vdots \\
			\vdots & \vdots & \vdots & \vdots & \vdots &\vdots & \vdots & \vdots \\
			0 & \cdots & 0 & g_0 & g_1 & g_2 & \cdots & g_{n-k} 
	\end{pmatrix} \Leftrightarrow \begin{pmatrix}
			g(x) &  &  &   \\
			 & xg(x)  &  &   \\
			 &  & \ddots &   \\
			 &  &  & x^{k-1}g(x)  \\
	\end{pmatrix}$ 
	es una matriz generadora de $\mathcal{C}$.
	\item Si $\alpha$ es la n-ésima raíz de la unidad en el cuerpo de extensión $\mathbb{F}_{q^n}$ entonces \[ 
	g(x) = \prod_s \mathcal{M}_{\alpha^s} (x)
	\]
	donde el producto es en un subconjunto representativo de las clases q-ciclotómicas módulo n.	
\end{enumerate}
\end{theorem}

\begin{proof}
Sea $g(x)$ un polinomio mónico de menor grado en $\mathcal{C}$. Como $\mathcal{C}$ es no nulo, ese polinomio existe. Si $c(x) \in \mathcal{C}$, entonces por el algoritmo de la división en $\mathbb{F}_q[x]$, $c(x) = g(x)h(x) + r(x)$, donde $r(x) = $ o $deg(r(x)) < deg(g(x))$. Como $\mathcal{C}$ es un ideal en $\mathcal{R}_n$, $r(x) \in \mathcal{C}$ y como el grado de $g(x)$ es mínimo, implica que $r(x) = 0$. Esto prueba 1) y 2).

Por el algoritmo de la división, $x^n-1 = g(x)h(x)+r(x)$, donde de nuevo $r(x) = 0$ o $deg(r(x)) < deg(g(x))$ en  $\mathbb{F}_q[x]$. Como $x^n-1$ corresponde con la palabra código $0$ en $\mathcal{C}$ y $\mathcal{C}$ es un ideal en $\mathcal{R}_n$, entonces $r(x) \in \mathcal{C}$ que es una contradicción, a menos que $r(x) = 0$, lo que prueba 3).

Supongamos que $deg(g(x)) = n-k$. Por 2) y 3) , si $c(x) \in \mathcal{C}$ con $c(x) = 0$ o $deg(c(x)) < n $, entonces $c(x) = g(x)f(x)$ en $\mathbb{F}_q[x]$. Si $c(x) = 0$, entonces $f(x) = 0$. Si $c(x) \neq 0$, $deg(c(x)) < n $ y el grado del producto de dos polinomio es la suma de los grados de los polinomios y sabemos que $deg(g(x)) = n-k$ lo que implica que $deg(f(x)) < k$. Por tanto, 
\[
\mathcal{C} = \{ g(x)f(x) | f(x) = 0 \thinspace o \thinspace deg(f(x)) < k \}
\]

Así que $\mathcal{C}$ tiene como mucho dimensión k y $\{g(x),xg(x),\cdots,x^{k-1}g(x)\}$ expande a $\mathcal{C}$. Como estos k polinomios son de distinto grado, son independientes en $\mathbb{F}_q[x]$. Como su grado es como mucho $n-1$, son también independientes en $\mathcal{R}_n$, por lo que queda demostrado 4) y 5). Para 6), basta colocar por filas los elementos de la base y así obtenemos $\mathcal{G}$. El último punto se obtiene del Teorema \ref{th:factorizar_xn}. 
\end{proof}

A partir de este teorema podemos extraer el siguiente corolario.

\begin{corollary}
\label{co:generador_unico}
Sea $\mathcal{C}$ un código cíclico no nulo en $\mathcal{R}_n$. Son equivalentes:
\begin{enumerate}
	\item $g(x)$ es el único polinomio mónico de menor grado en $\mathcal{C}$.
	\item $\mathcal{C} = <g(x)>$, $g(x)$ es mónico y $g(x) | (x^n-1)$. 
\end{enumerate}

\end{corollary}

\begin{proof}
1) implica 2) se ha demostrado en el Teorema \ref{th:base_ciclicos}. Asumiendo 2), sea $g_1(x)$ un polinomio mónico de menor grado en $\mathcal{C}$. Por la demostración del Teorema \ref{th:base_ciclicos} apartados 1) y 2), $g_1(x) | g(x)$ en $\mathbb{F}_q[x]$ y $\mathcal{C} = < g_1(x)>$. Como $ g_1(x) \in \mathcal{C} = < g(x) >$, entonces $g_1(x) = g(x)a(x) + (x^n-1)b(x)$ en $\mathbb{F}_q[x]$. Como $g(x) | (x^n-1)$, $g(x) | g(x)a(x) + (x^n-1)b(x)$ y por tanto $g(x) | g_1(x)$. Como $g_1(x)$ y $g(x)$ son mónicos  y se dividen entre ellos en $\mathbb{F}_q[x]$, son iguales.
\end{proof}

Del Teorema \ref{th:base_ciclicos}, obtenemos que $g(x)$ es un polinomio mónico que divide a $x^n-1$ y genera a $\mathcal{C}$. Del corolario, obtenemos que además $g(x)$ es único. Luego, a este polinomio lo llamaremos el \textit{polinomio generador} del código cíclico $\mathcal{C}$.

Así que hay una correspondencia uno a uno entre los códigos cíclicos no nulos y los divisores de $x^n-1$. Con el fin de tener una correspondencia biyectiva entre todos los códigos cíclicos de $\mathcal{R}_n$ y todos los divisores mónicos de $x^n-1$, definimos que el \textit{polinomio generador} del código cíclico cero ${0}$ sea $x^n-1$. Esto da lugar al siguiente corolario.

\begin{corollary}
El número de códigos cíclicos en $\mathcal{R}_n$ es igual a $2^m$ donde m es el número de clases q-ciclotómicas módulo n. Además, las dimensiones de los códigos cíclicos son todas las posibles sumas de los tamaños de las clases q-ciclotómicas módulo n.

\end{corollary}

\begin{exampleth}
Para el polinomio $x^7-1$ en $\mathbb{F}_2$, calculamos sus clases \textit{2-ciclotómicas} que son $\mathcal{C}_0 = \{ 0 \}$ , $\mathcal{C}_1 = \{ 1,2,4 \}$ y $\mathcal{C}_3 = \{ 3,5,6 \}$. Luego, sus tamaños son 1,3 y 3, por tanto, por el corolario anterior sabemos que hay $2^3 = 8$ códigos cíclicos y sus dimensiones son : $0,1,3,3,4,4,6,7$ . Veamos los polinomios generadores de cada uno en la siguiente tabla.

\begin{table}[b]
 \begin{tabular}{ c | c | c}
	i & dimensión & $g_i(x)$ \\ \hline
	0 & 0 & $ x^7 + 1$ \\
	1 & 1 & $ (x^3+x+1)(x^3+x^2+1) = x^6+x^5+x^4+x^3+x^2+x+1$ \\ 
	2 & 3 & $x^3+x+1 $ \\
	3 & 3 & $ x^3+x^2+1$ \\
	4 & 4 & $(x+1)(x^3+x+1) = x^4+x^3+x^2+1$ \\
	5 & 4 & $(x+1)(x^3+x^2+1) = x^4+x^2+x+1$ \\
	6 & 6 & $x+1$ \\ 
	7 & 7 & 1

	\end{tabular}
\caption{Polinomios generadores de distintos códigos cíclicos.}
\end{table}
\end{exampleth}

\subsection{Ceros de un código cíclico}

\begin{definition}
Sea $\mathcal{C}$ un código cíclico en $\mathcal{R}_n$ con polinomio generador $g(x)$. Luego, $g(x) = \prod_{s} \mathcal{M}_{\alpha^s}(x) = \prod_{s} \prod_{i \in \mathcal{C}_s} (x-\alpha^i) $ donde \textit{s} recorre un subconjunto de los representantes de las clases \textit{q-ciclotómicas} $\mathcal{C}_s$ módulo n. Sea T $ = \cup_s \mathcal{C}_s$ la unión de estas clases \textit{q-ciclotómicas}. Llamaremos \textbf{ceros} de un código cíclico a $\mathcal{Z} = \{ \alpha^i \thinspace | \thinspace i \in T \}$ y \textbf{no-ceros} a $\{ \alpha^i \thinspace | \thinspace i \not\in T \}$ . Al conjunto T, lo llamaremos \textbf{conjunto de definición} de $\mathcal{C}$
\end{definition}

Nos damos cuenta de que T y por tanto, el conjunto de ceros y no-ceros, determina completamente al polinomio generador $g(x)$. Por el Teorema \ref{th:base_ciclicos} , la dimensión de $\mathcal{C}$ es $ n - \mid T \mid$ y $\mid T \mid$ es el grado de $g(x)$


\begin{exampleth} Mostraremos el conjunto de definición para cada código cíclico relativo a la raíz primitiva $\alpha$ 

\begin{table}[h]
\begin{tabular}{ c | c | c | c |}
	i & dimensión & $g_i(x)$ & conjunto de definición \\ \hline
	0 & 0 & $ x^{10} - 1$  & $\{ 0,1,2,3,4,5,6,7,8,9 \}$ \\
	1 & 1 & $x^9+x^8+x^7+x^6+x^5+x^4+x^3+x^2+x+1$ & $\{ 1,2,3,4,5,6,7,8,9 \}$ \\ 
	2 & 1 & $  x^9+x^8+x^7+2x^6+x^5+2x^4+x^3+2x^2+x+2$ & $\{ 0,1,2,3,4,6,7,8,9 \}$ \\
	3 & 2 & $  x^8+x^6+x^4+x^2+1$ & $\{ 1,2,3,4,6,7,8,9 \}$  \\
	4 & 4 & $ x^6+2x^5+x+2$ & $\{ 0,2,4,5,6,8 \}$ \\
	5 & 4 & $ x^6+x^5+2x+2$ & $\{ 0,1,3,5,7,9 \}$ \\
	6 & 5 & $ x^5+1$ & $\{ 2,4,5,6,8 \}$ \\ 
	7 & 5 & $x^5+x^4+2x^3+x^2+2x+2$ & $\{ 0,2,4,6,8 \}$ \\
	8 & 5 &  $x^5+2x^4+2x^3+2x^2+2x+1$ & $\{ 1,3,5,7,9 \}$ \\
	9 & 5 & $x^5 + 2$ &$\{ 0,1,3,7,9 \}$ \\
	10 & 6 & $x^4+2x^3+x^2+2x+1$ & $\{ 2,4,6,8 \}$ \\
	11 & 6 & $x^4+x^3+x^2+x+1$ & $\{ 1,3,7,9 \}$ \\
	12 & 8 & $x^2+3x+2$ & $\{ 0,5 \}$ \\
	13 & 9 & $x+1$ & $\{ 5 \}$ \\
	14 & 9 & $x+2$ & $\{ 0 \}$ \\
	15 & 10 & $1$ & $ \emptyset $

	\end{tabular}
 \caption{Conjunto de definición de cada código cíclico.}
\end{table}	
\end{exampleth}

El siguiente teorema nos da propiedades básicas de los códigos cíclicos en relación a los conjuntos de definición.

\begin{theorem}
\label{th:prop_conj_def}

Sea $\alpha$ la n-ésima raíz primitiva de la unidad en un cuerpo de extensión de $\mathbb{F}_q$. Sea $\mathcal{C}$ un código cíclico de longitud n en $\mathbb{F}_q$ con conjunto de definición T y polinomio generador $g(x)$. Se verifica lo siguiente:
\begin{enumerate}
	\item T es la unión de las clases q-ciclotómicas módulo n.
	\item $g(x) = \prod_{i \in T} (x-\alpha^i)$.
	\item $c(x) \in \mathcal{R}_n \Leftrightarrow \thinspace c(\alpha^i) = 0 \thinspace \forall i \in T$.
 	\item La dimensión de $\mathcal{C}$ es $ n - \mid T \mid$.
\end{enumerate}
\end{theorem}

\begin{proof}
    Por definición, una clase $q$-ciclotómica módulo $n$ es un conjunto de enteros $\mathcal{C}_s$ tal que $\mathcal{C}_s \equiv s \thinspace ( mod \thinspace n)$ por tanto, $\mathcal{C}_s$ contiene un representante de cada clase de equivalencia módulo $n$. Como $T$ es el conjunto de definición de $\mathcal{C}$, contiene un representante de cada clase de equivalencia módulo $n$. Luego $T$ es la unión de clases $q$-ciclotómicas módulo $n$ y hemos demostrado 1).

    Para 2), consideramos el polinomio generador $g(x)$ de $\mathcal{C}$, como $\mathcal{C}$ es un código cíclico, el polinomio generador lo obtenemos del conjunto de definición, es decir, es el producto de todos los factores $(x-\alpha^i)$ con $i \in T$. Por tanto, $g(x) = \prod_{i \in T} (x-\alpha^i)$.

    Para 3), consideramos primero que $c(x) \in \mathcal{R}_n$, luego $c(x)$ satisface el polinomio generador y al evaluar $\alpha^i$ con $i \in T$ en $c(x)$, obtenemos que $c(\alpha^i) = 0$ porque $g(\alpha^i) = 0$.
    
    Supongamos que $c(\alpha^i) = 0$ para $i \in T$. Podemos escribir $c(x) = g(x)q(x) + r(x)$ con $q(x)$ y $r(x)$ son polinomios con $deg(r) < deg(g)$. Evaluando en $\alpha^i$, obtenemos que $c(\alpha^i) = 0 = g(\alpha^i)q(\alpha^i) + r(\alpha^i) $ y como $g(\alpha^i) = 0$ obtenemos que $r(\alpha^i) = 0$ para $i \in T$. Pero $r(x)$ es un polinomio con grado menor que $g(x)$ luego debe ser el polinomio cero. En ese caso, $c(x) = g(x)q(x) $ y, por consiguiente, $c(x) \in \mathcal{R}_n$.

    Para 4), la dimensión de un código cíclico es igual al grado de su polinomio generador. Por 2), sabemos que $g(x) = \prod_{i \in T} (x-\alpha^i)$ y los $(x-\alpha^i)$ son factores de grado $1$. En ese caso, $deg(g) = \mid T \mid$ y como la longitud de $\mathcal{C}$ es $n$. Hemos demostrado que la dimensión de $\mathcal{C} = n - \mid T \mid $.

    
\end{proof}

\subsection{Distancia mínima de códigos cíclicos}
 
 Es importante saber cual es la  distancia mínima que puede alcanzar cualquier código, para así poder determinar su capacidad de corrección de errores. Luego, es útil encontrar cotas inferiores para la distancia mínima. Una de las cotas más antiguas es la cota de \textit{Bose-Ray-Chaudhuri-Hocquenghem}, normalmente conocida como la \textit{cota BCH} que nos servirá para definir los códigos BCH más adelante. 
 
 Antes de definir la cota BCH, vamos a dar un lema sobre el determinante de la matriz de Vandermonde que nos servirá para probar dicha cota.
 
 \begin{lemma}
 \label{le:vandermonde}
 $det \thinspace V = \prod_{1 \leq i < j \leq s} (\alpha_j - \alpha_i)$ . En particular, V es regular si los elementos $\alpha_1, \cdots, \alpha_s$ son distintos.
 \end{lemma}


\begin{theorem}[\textbf{Cota inferior BCH}]
\label{th:cota_bch}
Sea $\mathcal{C}$ un código cíclico de longitud n sobre $\mathbb{F}_q$ con conjunto de definición T. Supongamos que $d$ es el peso mínimo de $\mathcal{C}$. Asumimos que T contiene los $\delta -1$ elementos consecutivos para un entero $\delta$. Entonces $d \geq \delta$.
\end{theorem}

\begin{proof}
Asumimos que $\mathcal{C}$ tiene ceros que incluye a $\alpha^b,\alpha^{b+1}, \cdots , \alpha^{b+\delta-2}$. Sea $c(x)$ una palabra código no-nula en $\mathcal{C}$ de peso $w$ y sea 
\[ 
	c(x) = \sum_{j=1}^w c_{i_j}x^{i_j}
\]

Asumimos por el contrario que $w < \delta$. Como $c(\alpha^i) = 0$ para $ b \leq i \leq b+\delta -2$, $Mu^T = 0$, donde 

$ M = \begin{pmatrix}
	 \alpha^{i_1b} & \alpha^{i_2b} & \cdots & \alpha^{i_wb} \\
	 \alpha^{i_1(b+1)} & \alpha^{i_2(b+1)} & \cdots  & \alpha^{i_w(b+1)} \\
	 \vdots & \vdots & \vdots & \vdots  \\
     \alpha^{i_1(b+w-1)} & \alpha^{i_2(b+w-1)} & \cdots  & \alpha^{i_w(b+w-1)} \\
	\end{pmatrix}$
	
y $u=c_{i_1}c_{i_2}\cdots c_{i_w}$. Como $u \neq 0$, M es una matriz singular y por tanto $det \thinspace M = 0$. Pero $det \thinspace M = \alpha^{(i_1+i_2+\cdots + i_w)^b}det \thinspace V$, donde V es la matriz de Vandermonde :

$ V = \begin{pmatrix}
	 1 & 1 & \cdots & 1 \\
	 \alpha^{i_1} & \alpha^{i_2} & \cdots  & \alpha^{i_w} \\
	 \vdots & \vdots & \vdots & \vdots  \\
     \alpha^{i_1(w-1)} & \alpha^{i_2(w-1)} & \cdots  & \alpha^{i_w(w-1)} \\
	\end{pmatrix}$
	
Como los $\alpha^{i_j}$ son distintos, $det \thinspace V \neq 0$ por el Lema \ref{le:vandermonde}, contradiciendo que $det \thinspace M = 0$.
\end{proof}


\begin{exampleth}
Sea $\mathcal{C}$ el $[10,2,d]$ código cíclico binario con conjunto de definición $T = \{ 1,2,3,4,6,7,8,9 \}$. Si aplicamos la cota BCH a $\mathcal{C}$, vemos que $d \geq 5$ ya que el conjunto con más elementos consecutivos es de tamaño 4. 
\end{exampleth}

\section{Códigos BCH y Reed-Solomon}

En esta sección examinaremos una de las muchas importantes familias de códigos cíclicos que se conocen como los códigos BCH junto a una subfamilia que se la conoce como códigos Reed-Solomon.

\subsection{Códigos BCH}

Los códigos BCH son códigos cíclicos diseñados para aprovecharse de la cota BCH. Queremos construir un código cíclico $\mathcal{C}$ de longitud $n$ sobre $\mathbb{F}_q$ que tenga simultáneamente un peso mínimo alto y una alta dimensión. Tener un peso mínimo alto, con la cota BCH , se puede obtener elegiendo un conjunto de definición T de $\mathcal{C}$ con un número grande de elementos consecutivos. Ya que la dimensión de $\mathcal{C}$ es $n - \mid T \mid$, si tiene distancia mínima al menos $\delta$, podemos elegir un conjunto de definición tan pequeño como nos sea posible tal que sea la unión de las clases q-ciclotómicas con $\delta -1$ elementos consecutivos. 


\begin{definition}
Sea $\delta$ un entero tal que $ 2 \leq \delta \leq n$. Un \textbf{código BCH} $\mathcal{C}$ en $\mathbb{F}_q$ con longitud $n$ y distancia predefinida $\delta$ es un código cíclico con conjunto de definición 
\[
T = \mathcal{C}_b \cup \mathcal{C}_{b+1} \cup \cdots \cup \mathcal{C}_{b+\delta -2}
\]

donde $\mathcal{C}_i$ es la clase q-ciclotómica módulo n que contiene a $i$. Por la cota BCH, este código tiene al menos distancia mínima $\delta$.
\end{definition}


\begin{theorem}
\label{th:bch_dist_min}
Un código BCH con distancia predefinida $\delta$ tiene peso mínimo al menos $\delta$.
\end{theorem}
\begin{proof}
El conjunto de definición T que hemos definido anteriormente tiene $\delta -1$ elementos consecutivos, luego el resultado lo obtenemos de aplicar la cota BCH.
\end{proof}

Si variamos el valor de $b$ en el conjunto de definición, podemos obtener una variedad de códigos con diferentes distancias mínimas y dimensiones. Cuando $b=1$, $\mathcal{C}$ se le conoce como \textbf{código BCH en sentido estricto}. Como con cualquier código cíclico, si $n = q^t-1$, entonces $\mathcal{C}$ se le conoce como \textbf{código BCH primitivo}.

\begin{exampleth}
\label{ex:construir_BCH}
Vamos construir un código BCH sobre $\mathbb{F}_2$ de longitud $15$. Las clases 2-ciclotómicas módulo $15$ son las calculadas en el Ejemplo \ref{ex: clase_mod_quince} :

$\mathcal{C}_0 = \{ 0 \}$ , $\mathcal{C}_1 = \{ 1,2,4,8 \}$, $\mathcal{C}_3 = \{ 3,6,9,12 \}$, $\mathcal{C}_5 = \{ 5,108 \}$ , $\mathcal{C}_7 = \{ 7,11,13,14 \}$.


Como $ord_{15}(2) = 4$, $x^{15}-1$ tiene todas sus raíces en $\mathbb{F}_{2^4}$.  Tenemos que el código BCH en sentido estricto $\mathcal{C}_1$ con distancia predefinida 3, tiene de conjunto de definición $ T = \mathcal{C}_1 \cup \mathcal{C}_2 = \{ 1,2,4,8 \}$ y de polinomio generador $g_1(x) = x^4 + x + 1$. Por el Teorema \ref{th:bch_dist_min}, $\mathcal{C}_1$ tiene peso mínimo al menos 3.

\end{exampleth}




\subsection{Códigos Reed-Solomon}

Definiremos los códigos Reed-Solomon como una subfamilia de los códigos BCH. 

\begin{definition}

Un \textbf{código Reed-Solomon}, abreviado como \textit{código RS}, sobre $\mathbb{F}_q$ es un código BCH de longitud $n = q-1$. 
\end{definition}

Luego, $ord_n(q) = 1$ lo que implica que todos los factores irreducibles de $x^n-1$ son de grado $1$ y todas sus clases q-ciclotómicas tienen tamaño $1$. De hecho,las raíces de $x^n-1$ son exactamente los elementos no nulos de $\mathbb{F}_q$, y una n-ésima raíz primitiva de la unidad es un elemento primitivo de $\mathbb{F}_q$. Así que, si $\mathcal{C}$ tiene distancia predefinida $\delta$, el conjunto de definición de $\mathcal{C}$ tiene tamaño $\delta-1$ y es $T = \{ b, b+1,\cdots, b+\delta-2 \}$ para algún entero $b$. Por el Teorema \ref{th:bch_dist_min} y la cota de Singleton, la dimensión $k$ y la distancia mínima $d$ de $\mathcal{C}$ satisfacen que $k = n -\delta + 1 \geq n-d+1 \geq k$. Luego, de ambas desigualdades se deduce la igualdad lo que implica que $ d = \delta$ y $k = n-d+1$.


\begin{theorem}
\label{th:crear_RS}
Sea $\mathcal{C}$ un código RS sobre $\mathbb{F}_q$ de longitud $n = q-1$ y con distancia predefinida $\delta$. Entonces :
\begin{enumerate}
	\item $\mathcal{C}$ tiene como conjunto de definición $T = \{ b, b+1,\cdots, b+\delta-2 \}$ para algún entero $b$.
	\item $\mathcal{C}$ tiene distancia mínima $ d = \delta$ y dimensión $k = n-d+1$.
\end{enumerate}
\end{theorem}

\begin{proof}
    Para demostrar 1) vamos a ver que existe un entero $b$ tal que cualquier palabra código no nula evaluada en $b,b+1,\cdots,b+\delta-2$ vale cero .
    
    Como $\mathcal{C}$ es un código RS, su polinomio generador $g(x)$ tiene grado $k = n-\delta+1$ que es un divisor de $x^n-1$, por tanto, las raíces de $g(x)$ son raíces $n$-ésimas de la unidad en $\mathbb{F}_q$ excluyendo el $1$. 

    Consideremos una palabra código arbitraria $c(x) \in \mathcal{C}$ y $\alpha$ la raíz $n$-ésima de la unidad en $\mathbb{F}_q$. Sabemos que $c(\alpha),c(\alpha^2),\cdots,c(\alpha^{n-1})$ valen cero puesto que son raíces de $g(x)$.
    
    Consideramos ahora el polinomio $f(x) = c(x)(x-b)(x-(b+1))\cdots(x-(b+\delta-2))$ con $b$ un entero, por construcción vale cero en $b,b+1,\cdots,b+\delta-2$ y tiene $deg(f) = k+\delta-1 \leq n$ ya que $k+\delta-1 = (n-\delta+1) + \delta-1 = n$. Como tiene grado menor que $n$, como mucho tenemos $n-1$ raíces y, por consiguiente, $f(x)$ no tiene todas las $n$-ésimas raíces de la unidad en $\mathbb{F}_q$. Esto implica que hay palabras código que en $b,b+1,\cdots,b+\delta-2$ no valen cero y ya confirmamos que $T = \{ b,b+1,\cdots,b+\delta-2 \}$ es un conjunto de definición.

    Para demostrar 2), por el Teorema \ref{th:bch_dist_min} como un código RS es también un código BCH sabemos que la distancia mínima es al menos $\delta$. Consideremos ahora una palabra código $c(x) \in \mathcal{C}$ con grado $k-1$, si tuviera menos podemos multiplicar $c(x)$ por un factor apropiado para que tenga ese grado sin cambiar su evaluación en las raíces del polinomio generador.

    Sabemos ahora que el peso de $c(x)$ es como mucho $k-1$ y como la dimensión de $\mathcal{C}$ es k, debe existir una palabra código con peso $k-1$. Sin embargo, como la distancia mínima $\delta$ debemos tener una palabra código con peso $\delta$. Por tanto, $\mathcal{C}$ tiene distancia mínima $d = \delta$ y dimensión $k = n-d+1$.
\end{proof}
\begin{exampleth}
Vamos a definir un código Reed-Solomon utilizando el Teorema \ref{th:crear_RS}
. Un código de longitud $8$ y conjunto de definición $\{1,2,3 \}$ es un código $\mathcal{C}$ con distancia mínima $4$ y es un $[8,5,4]$ código. 
\end{exampleth}

\subsection{Algoritmo de Decodificación de Peterson-Gorensein-Zierler}

Sea $\mathcal{C}$ un código BCH sobre $\mathbb{F}_q$ con longitud $n$ y distancia predefinida $\delta$. Como la distancia mínima de $\mathcal{C}$ es, al menos, $\delta$, podemos corregir al menos $t = \lfloor (\delta-1)/2 \rfloor$ errores. El algoritmo de decodificación Peterson-Gorenstein-Zierler puede corregir hasta $t$ errores. Mientras que el algoritmo se puede aplicar a cualquier código BCH, podemos simplicarlo si asumimos que $\mathcal{C}$ es en sentido estricto. Por lo tanto, el conjunto de definición T de $\mathcal{C}$ asumimos que contiene $\{ 1,2,\cdots,\delta-1 \}$, con $\alpha$ siendo la n-ésima raíz primitiva de la unidad en un cuerpo de extensión $\mathbb{F}_{q^m}$ de $\mathbb{F}_q$, donde $m = ord_n(q)$, usado para determinar este conjunto de definición. El algoritmo requiere cuatro pasos que vamos a describir  en orden y, más tarde, resumir.


Supongamos que recibimos $y(x)$, asumimos que $y(x)$ difiere de una palabra código $c(x)$ en al menos $t$ coordenadas. Por tanto, $y(x) = c(x) + e(x)$, donde $c(x) \in \mathcal{C}$ y $e(x)$ es el vector de error con peso $v \leq t$. Supongamos que los errores ocurren en coordenadas desconocidas $k_1,k_2,\cdots,k_v$. Luego,

\[
e(x) = e_{k_1}x^{k_1} + e_{k_2}x^{k_2} + \cdots + e_{k_v}x^{k_v}
\]

Una vez determinemos $e(x)$, nos falta encontrar dónde ocurren los errores $k_j$ y sus magnitudes $e_{k_j}$, entonces podemos decodificar el vector recibido como $c(x) = y(x) - e(x)$. Recordemos que por el Teorema \ref{th:prop_conj_def}, $c(x) \in \mathcal{C}$ si y solo si $c(\alpha^i) = 0 \thinspace \forall i \in T$. En particular, $y(\alpha^i) = c(\alpha^i) + e(\alpha^i) = e(\alpha^i) \thinspace \forall 1 \leq i \leq 2t$, ya que $2t \leq \delta-1$. Para $1 \leq i \leq 2t$, definimos el \textbf{síndrome} $S_i$ de $y(x)$ como un elemento $S_i = y(\alpha^i)$ en $\mathbb{F}_{q^m}$

El \textit{primer paso} del algoritmo es calcular los síndromes $S_i = y(\alpha^i)$ para $1 \leq i \leq 2t$ del vector recibido.

%\begin{theorem}
%label{th:sindromes}
%$S_{iq} = S_i^q \thinspace \forall i \geq 1$.
%\end{theorem}

Los síndromes dan lugar a un sistema de ecuaciones relacionando las localizaciones desconocidas de los errores y sus magnitudes. Además, los síndromes satisfacen:

\[ 
S_i = y(\alpha^i) = \sum_{j=1}^v e_{k_j}(\alpha^i)^{k_j} = \sum_{j=1}^v e_{k_j}(\alpha^{k_j})^i
\]

para $1 \leq i \leq 2t$. Para simplicar la notación, para los $1 \leq j \leq v$, llamaremos $E_j = e_{k_j}$ a \textit{la magnitud del error en la coordenada $k_j$} y  $X_j = \alpha^{k_j}$ a el índice correspondiente a la localización del error $k_j$. Por el Teorema \ref{th:elementos_primitivos}  %ESTA EN EL CAPITULO 0, 
si $\alpha^i = \alpha^k$ para $i$ y $k$ entre $0$ y $n-1$, entonces $i = k$. Por tanto, sabemos que $X_j$ determina unívocamente la localización del error $k_j$. Con esta notación tenemos:

\begin{equation}
\label{eq:paso_uno}
S_i =  \sum_{j=1}^v E_jX_j^i \quad para \quad 1 \leq i \leq 2t
\end{equation} 



del cual podemos obtener el siguiente sistema de ecuaciones:
\begin{equation}
\label{eq:sistema_paso_uno} S_1 = E_1X_1 + E_2X_2 + \cdots + E_vX_v 
 \end{equation}
 
  $\hspace{5cm} S_2 = E_1X_1^2 + E_2X_2^2 + \cdots + E_vX_v^2$ 
 
  $\hspace{5cm} S_3 = E_1X_1^3 + E_2X_2^3 + \cdots + E_vX_v^3 $
  
   $\hspace{8cm} \vdots $
     
  $\hspace{5cm} S_{2t} = E_1X_1^{2t} + E_2X_2^{2t} + \cdots + E_vX_v^{2t}$




Este sistema no es lineal en las $X_j$s con coeficientes desconocidos $E_j$. La estrategia es usar (\ref{eq:paso_uno}) para crear un sistema lineal con nuevas variables $\sigma_1,\sigma_2, \cdots, \sigma_v$ de las que obtendremos los números de localización de los errores. Después, resolvemos el sistema (\ref{eq:sistema_paso_uno}) para obtener las magnitudes.

\begin{definition}
Llamamos \textbf{polinomio localizador de errores} a 
\[ 
\sigma(x) = (1-xX_1)(1-xX_2)\cdots(1-xX_v) = 1 + \sum_{i=1}^v \sigma_ix^i
\]
\end{definition}

Las raíces de $\sigma(x)$ son los inversos de los números de localización de los errores y por tanto, 

\[ 
\sigma(X_j^{-1}) = 1 + \sigma_1X_j^{-1} + \sigma_2X_j^{-2} + \cdots + 	\sigma_vX_j^{-v} = 0
\]
 para $ 1 \leq j \leq v$. Multiplicando por $E_jX_j^{i+v}$ tenemos,
 
 \[ 
 E_jX_j^{i+v} + \sigma_1E_jX_j^{i+v-1} + \cdots + \sigma_vE_jX_j^{i} = 0
 \]

para cualquier $i$. Sumando esto para $j$ con $1 \leq j \leq v$, obtenemos 

\begin{equation}
\label{eq:sumatorio_paso_uno}
 \sum_{j=1}^v E_jX_j^{i+v} + \sigma_1\sum_{j=1}^v E_jX_j^{i+v-1} + \cdots + \sigma_v\sum_{j=1}^v E_jX_j^{i} = 0
\end{equation}

Siempre que $ 1 \leq i$ y $i+v \leq 2t$, estas sumas son los síndromes obtenidos en (\ref{eq:paso_uno}). Porque $ v \leq t$, (\ref{eq:sumatorio_paso_uno}) se convierte en:

\[ 
S_{i+v} + \sigma_1S_{i+v-1} + \sigma_2S_{i+v-2} + \cdots + \sigma_vS_i = 0
\]

o 

\begin{equation}
\label{eq:sindromes_paso_uno}
 \sigma_1S_{i+v-1} + \sigma_2S_{i+v-2} + \cdots + \sigma_vS_i = - S_{i+v} 
\end{equation}

para $ 1 \leq i \leq v$. Por tanto, podemos encontrar los valores $\sigma_k$s si resolvemos la siguiente ecuación matricial.
\begin{equation}
\label{eq:sistema_matricial}
\begin{pmatrix}
			S_1 & S_2 & S_3 & \cdots & S_{v-1} & S_v \\
			S_2 & S_3 & S_4 & \cdots  & S_v & S_{v+1} \\
			S_3 & S_4 & S_5 & \cdots & S_{v+1} & S_{v+2} \\ 
 			\vdots & \vdots & \vdots & \vdots & \vdots &\vdots & \vdots & \vdots \\
			S_v & S_{v+1} & S_{v+2} & \cdots  & S_{2v-2} & S_{2v-1} \\
	\end{pmatrix}
	\begin{pmatrix}
			\sigma_v \\
			\sigma_{v-1} \\
			\sigma_{v-2}  \\ 
 			\vdots \\
			\sigma_1  \\
	\end{pmatrix} = \begin{pmatrix}
			-S_{v+1} \\
			-S_{v+2} \\
			-S_{v+3}  \\ 
 			\vdots \\
			-S_{2v}  \\
	\end{pmatrix}
\end{equation}

El \textit{segundo paso} del algoritmo será resolver (\ref{eq:sistema_matricial}) para $\sigma_1,\cdots,\sigma_v$. Cuando este paso esté completado, los $\sigma(x)$ estarán determinados. Sin embargo, no conocemos $v$, y por tanto, no podemos saber el tamaño del sistema involucrado. Queremos buscar la solución que tenga el menor valor de $v$ posible y por ello, tenemos el siguiente lema.

\begin{lemma}
Sea $\mu \leq t$ y sea 
$M_\mu = \begin{pmatrix}
			S_1 & S_2 & \cdots &  S_\mu \\
			S_2 & S_3  & \cdots &  S_{\mu+1} \\
 		\vdots & \vdots & \vdots & \vdots  \\
			S_\mu & S_{\mu+1} & \cdots & S_{2\mu-1} \\
	\end{pmatrix}$

Entonces $M_\mu$ es invertible si $\mu = v$ y singular si $\mu > v$, donde $v$ es el número de errores que han ocurrido.
\end{lemma}

\begin{proof}
Si $\mu > v$, sea $X_{v+1} = X_{v+2} = \cdots = X_\mu = 0$ y $E_{v+1} = E_{v+2} = \cdots = E_\mu = 0$. Tenemos $A_\mu$ y $B_\mu$ que son 

$A_\mu = \begin{pmatrix}
			1 & 1 & \cdots &  1 \\
			X_1 & X_2  & \cdots &  X_\mu \\
 			\vdots & \vdots & \vdots & \vdots  \\
			X_1^{\mu-1} & X_2^{\mu-1} & \cdots & X_\mu^{\mu-1} 
	\end{pmatrix}$ 
	y $B_\mu = \begin{pmatrix}
			E_1X_1 & 0 & \cdots &  0 \\
			0 & E_2X_2  & \cdots &  0 \\
 			\vdots & \vdots & \vdots & \vdots  \\
			0 & 0 & \cdots & E_\mu X_\mu 
	\end{pmatrix}$

entonces $M_\mu = A_\mu B_\mu A_\mu^T$. Por tanto, $det(M_\mu) = det(A_\mu) det(B_\mu) det(A_\mu)$. Si $\mu > v$, $det(B_\mu) = 0$ ya que $B_\mu$ es una matriz diagonal con $0$ en la diagonal. Si $\mu = v$, entonces $det(B_\mu) \neq 0$, ya que $B_\mu$ es una matriz diagonal con elementos no nulos en la diagonal. Además, $det(A_\mu) \neq 0$, por el Lema \ref{le:vandermonde}, porque $A_\mu$ es una matriz de Vandermonde con $X_1,\cdots,X_\mu$ distintos. Por tanto, $M_\mu$ es invertible si $\mu = v$.
\end{proof}

Para ejecutar el segundo paso del algoritmo, intentamos conocer el número $v$ de errores. Llamaremos $\mu$ a ese intento y empezaremos con $\mu = t$, que es el número más grande que puede tomar $v$. La matriz de coeficientes del sistema lineal (\ref{eq:sistema_matricial}) que intentamos resolver es $M_\mu = M_t$, por el lema anterior. Si $M_\mu$ es singular, entonces reducimos $\mu$ a $\mu = t-1$ y vemos si $M_\mu = M_{t-1}$ es singular. Continuamos con este proceso hasta encontrar alguna $M_\mu$ invertible. Con $v = \mu$, resolvemos (\ref{eq:sistema_matricial}), y por tanto, obtenemos $\sigma(x)$. 

El \textit{tercer paso} es encontrar las raíces de $\sigma(x)$ e invertirlas para determinar los números de localización de los errores. Se suele completar haciendo una búsqueda exhaustiva comprobando $\sigma(\alpha^i)$ para $ 0 \leq i < n$.

El \textit{cuarto paso} es insertar los números obtenidos en el paso tres en (\ref{eq:sistema_paso_uno}) y resolver el sistema lineal para las magnitudes de los errores $E_j$. De hecho, solo necesitamos considerar las primeras $v$ ecuaciones en (\ref{eq:sistema_paso_uno}) por el siguiente motivo. La matriz de coeficientes de las primeras $v$ ecuaciones tiene por determinante 


$det \begin{pmatrix}
			X_1 & X_2  & \cdots &  X_v \\
			X_1^2 & X_2^2  & \cdots & X_v^2 \\
 			\vdots & \vdots & \vdots & \vdots  \\
			X_1^v & X_2^v & \cdots & X_v^v 
	\end{pmatrix} = X_1X_2\cdots X_\mu \begin{pmatrix}
			1 & 1 & \cdots &  1 \\
			X_1 & X_2  & \cdots & X_v \\
 			\vdots & \vdots & \vdots & \vdots  \\
			X_1^{v-1} & X_2^{v-1} & \cdots & X_\mu^{v-1} 
	\end{pmatrix}  $

El determinante de la matriz de la derecha es el determinante de una matriz de Vandermonde, luego es no nulo y los $X_j$ son distintos.


Resumiendo, el \textbf{Algoritmo de Decodificación Peterson-Gorenstein-Zierler} para códigos BCH sigue los siguientes pasos: 

\begin{enumerate}
	\item Calcular los síndromes $S_i = y(\alpha^i)$ para $ 1 \leq i \leq 2t$.
	\item En el orden $\mu = t$, $\mu = t-1$, $\cdots$ decidir si $M_\mu$ es singular, parando para el primer valor de $\mu$ en el que $M_\mu$ es invertible. Cogemos $v = \mu$ y resolvemos (\ref{eq:sistema_matricial}) para obtener $\sigma(x)$.
	\item Encontramos las raíces de $\sigma(x)$, calculando $\sigma(\alpha^i)$ para $ 0 \leq i < n$. Invertimos esas raíces para obtener los número de localización de errores $X_j$.
	\item Resolvemos las primeras $v$ ecuaciones de (\ref{eq:sistema_paso_uno}) para obtener las magnitudes de los errores $E_j$. 
\end{enumerate}

\begin{exampleth}
\label{ex:algoritmo_pgz}
Sea $\mathcal{C}$ el $[15,5]$ código binario BCH en sentido estricto con distancia predefinida $\delta = 6 $, que tiene como conjunto de definición $T = \{ 3,5,6,7,9,10,11,12,13,14 \}$. Usando la  raíz primitiva $15$-ésima de la unidad $\alpha$ que podemos ver en la siguiente tabla,
\begin{table}[H]
\begin{tabular}{ c | c | c | c | c | c | c | c }

	 
$0000$ & $0$  & $1000$ & $\alpha^3$ & $0111$ & $\alpha^7$ & $1101$ & $\alpha^{11}$ \\$0001$ & $1$  & $1001$ & $\alpha^4$ & $1110$ & $\alpha^8$ & $0011$ & $\alpha^{12}$ \\
$0010$ & $\alpha$  & $1011$ & $\alpha^5$ & $0101$ & $\alpha^9$ & $0110$ & $\alpha^{13}$ \\
$0100$ & $\alpha^2$  & $1111$ & $\alpha^6$ & $1010$ & $\alpha^{10}$ & $1100$ & $\alpha^{14}$ \\
	\end{tabular}
\caption{\label{ta:seis} $\mathbb{F}_{16}$ con elemento primitivo $\alpha$ donde $\alpha^4 = \alpha^3 +1$}
\end{table}

Tenemos que el polinomio generador de $\mathcal{C}$ es $g(x) = x^{10}+x^9+x^8+x^6+x^5+x^2+1$.
Supongamos que $\mathcal{C}$ va a transmitir una palabra código y recibimos $y(x) = x^{12}+x^{10}+x^6+x^4+x^3+x+1$. Usando la Tabla \ref{ta:seis}, aplicando el primer paso obtenemos,

$S_1 = 1 + \alpha + \alpha^3 + \alpha^4 + \alpha^6 + \alpha^{10} + \alpha^{12} = \alpha^2$  

$S_2 =  1 + \alpha^2 + \alpha^6 + \alpha^8 + \alpha^{12} + \alpha^{20} + \alpha^{24} = \alpha^{4}$

$S_3 = 1 + \alpha^3 + \alpha^{9} + \alpha^{12} + \alpha^{18} + \alpha^{30} + \alpha^{36} = \alpha^{4}$

$S_4 = 1 + \alpha^4 + \alpha^{12} + \alpha^{16} + \alpha^{24} + \alpha^{40} + \alpha^{48} = \alpha^8$

Para el paso dos, denotamos

$M_2 = \begin{pmatrix}
			S_1 & S_2  \\
			S_2 & S_3
	\end{pmatrix} = \begin{pmatrix}
			\alpha^2 & \alpha^4  \\
			\alpha^4 & \alpha^4
	\end{pmatrix}$

que es invertible ya que $det(M_2) = \alpha^2 \cdot \alpha^4 + \alpha^4 \cdot \alpha^4 = 1$  y su inversa es 

$M_2^{-1} = \begin{pmatrix}
			\alpha^4 & \alpha^4  \\
			\alpha^4 & \alpha^2
	\end{pmatrix}$
	
Luego $v=2$, por tanto, es el número de errores cometidos y tenemos que resolver :

$\begin{pmatrix}
			S_1 & S_2  \\
			S_2 & S_3
	\end{pmatrix} \begin{pmatrix}
			\sigma_2 \\
			\sigma_1
	\end{pmatrix} = \begin{pmatrix}
			 -S_3  \\
			 -S_4
	\end{pmatrix} $ o $\begin{pmatrix}
			\alpha^2 & \alpha^4  \\
			\alpha^4 & \alpha^4
	\end{pmatrix} \begin{pmatrix}
			\sigma_2 \\
			\sigma_1
	\end{pmatrix} = \begin{pmatrix}
			 \alpha^4  \\
			 \alpha^8
	\end{pmatrix} $
	
La solución es $[\sigma_2 \thinspace \sigma_1 ]^T = M_2^{-1}[\alpha^4 \thinspace \alpha^8]^T = [\alpha^{11} \thinspace \alpha^2]^T$. Por tanto, el paso dos produce el polinomio de localización de errores $\sigma(x) = \alpha^{11} x^2 + \alpha^2 x + 1$. Por el paso tres, tenemos las raíces de $\sigma(x)$ que son $\alpha^{9}$ y $\alpha^{10}$, por tanto, los números de localización de errores son $X_1 = \alpha^6$ y $X_2 =\alpha^{5}$. 

Nos queda resolver el siguiente sistema:

\[
	\left.
		E_1 \alpha^6 + E_2 \alpha^5 = \alpha^2 \atop
		E_1 \alpha^{12} + E_2 \alpha^{10} = \alpha^4
		\right\} 
\]

Podemos observar rápidamente que $E_1 = E_2 = 1$, ya tenemos calculadas sus magnitudes. Así que, el vector de error es $e(x) = x^{6} + x^5$, y la palabra código transmitida es $c(x) = x^{12}+x^{10}+x^5+x^4+x^3+x+1$.
\end{exampleth}

\subsection{Algoritmo de Sugiyama}

El Algoritmo de Sugiyama es un refinamiento del algoritmo anterior para encontrar el polinomio de localización de errores. Concretamente, presentar una alternativa al paso dos del Algoritmo de Peterson-Gorenstein-Zierler. Este algoritmo es una aplicación relativamente simple pero ingeniosa del Algoritmo de Euclides.

\begin{definition}
Definimos el \textbf{polinomio evaluador de errores $\omega(x)$} como

\[
\omega(x) = \sum_{j=1}^v E_jX_j \prod_{j=1}^v (1-xX_i) = \sum_{j=1}^v E_jX_j \frac{\sigma(x)}{1-xX_j}
\]

\end{definition}

Notamos que $deg(\sigma(x)) = v$ y $deg(\omega(x)) \leq v-1$. Definimos los polinomios $S(x)$, que tienen como grado máximo $2t-1$ como 

\[
S(x) = \sum_{i=0}^{2t-1} S_{i+1}x^i
\]

donde los $S_i$ con $ 1 \leq i \leq 2t$ son los síndromes del vector recibido.

Expandiendo la parte derecha de la definición de polinomio evaluador de errores como una serie formal de potencias y usando (\ref{eq:paso_uno}) junto a la definición de $S(x)$, obtenemos,

\[ 
\omega(x) = \sigma(x)\sum_{j=1}^v E_jX_j \frac{\sigma(x)}{1-xX_j} = \sigma(x) \sum_{j=1}^v E_jX_j \sum_{i=0}^\infty (xX_j)^i 
\]
\[
 = \sigma(x) \sum_{i=0}^\infty ( \sum_{j=1}^v E_jX_j^{i+1})x^i \equiv \sigma(x) \sum_{i=0}^{2t-1} ( \sum_{j=1}^v E_jX_j^{i+1})x^i \thinspace (mod \thinspace x^{2t})  \]
 
 \[ \equiv \sigma(x)S(x) \thinspace (mod \thinspace x^{2t}) \]

Por tanto, tenemos lo que llamamos \textbf{ecuación clave}


\[ \omega(x) \equiv \sigma(x)S(x) \thinspace (mod \thinspace x^{2t}) \]

La siguiente observación sobre $\sigma(x)$ y $\omega(x)$ será importante más adelante.

\begin{lemma}
\label{le:primos_ec_clave}
Los polinomios $\sigma(x)$ y $\omega(x)$ son primos relativos.
\end{lemma}

\begin{proof}
Las raíces de $\sigma(x)$ son precisamente los $X_j^{-1}$ para $ 1 \leq j \leq v$. Pero 
\[
\omega(X_j^{-1}) = E_jX_j \prod_{i=1 \thinspace i \neq j}^v (1-X_j^{-1}X_i) \neq 0
\]

lo que prueba el lema.
\end{proof}

El Algoritmo de Sugiyama usa el Algoritmo de Euclides para resolver la ecuación clave, luego sigue de esta forma.

\begin{enumerate}
\item Supongamos que $f(x) = x^{2t}$ y $s(x) = S(x)$. Sea $r_{-1}(x) = f(x)$,$r_0(x) = s(x)$,$b_{-1}(x) = 0$ y $b_0(x) = 1$. 
\item  Repetimos las siguientes dos operaciones para encontrar $h_i(x)$,$r_i(x)$ y $b_i(x)$ por inducción para $i = 1,2,\cdots , I$ satisfaciendo que $deg(r_{I-1}(x)) \geq t$ y $deg(r_{I}(x)) < t$ :


$r_{i-2}(x) = r_{i-1}h_i(x) + r_i(x)$ , donde  $deg(r_i(x)) < deg(r_{i-1}(x))$


$ b_i(x) = b_{i-2}(x) - h_i(x)b_{i-1}(x)$
\item $\sigma(x)$ es algún múliplo escalar no nulo de $b_I(x)$
\end{enumerate}

Notamos que la $I$ del paso dos está bien definida ya que $deg(r_i(x))$ decrece estrictamente con $deg(r_{-1}(x)) > t$. Con el fin de probar que el Algoritmo de Sugiyama funciona, necesitamos el siguiente lema.

\begin{lemma}
\label{le:tocho_sugiyama}
Usando la notación del Algoritmo de Sugiyama, sea $a_{-1}(x) = 0$,$a_0(x) = 1$ y $ a_i(x) = a_{i-2}(x) - h_i(x)a_{i-1}(x)$ para $ i \geq 1$. Tenemos lo siguiente:
\begin{enumerate}
	\item $a_i(x)f(x) + b_i(x)s(x) = r_i(x)$ para $ i \geq -1$
	\item $b_i(x)r_{i-1}(x) - b_{i-1}(x)r_i(x) = (-1)^i f(x)$ para $ i \geq 0$
	\item $a_i(x)b_{i-1}(x) - a_{i-1}(x)b_i(x) = (-1)^{i+1} $ para $ i \geq 0$
	\item $deg(b_i(x)) + deg(r_{i-1}(x)) = deg(f(x))$ para $ i \geq 0$
\end{enumerate}

\end{lemma}

\begin{proof}
Vamos a probar todos los puntos por inducción. Para 1), los casos $I_0-1$ y $i=0$ se obtienen directamente del conjunto de valores iniciales del paso uno del Algoritmo de Sugiyama y los valores $a_{-1}(x)=1$ y $a_0(x) = 0$. Asumimos que se cumple 1) para $i-1$ veamos que se cumple para $i$, tenemos, 


\begin{eqnarray*}
a_i(x)f(x) + b_i(x)s(x) & = & [a_{i-2}(x) -h_i(x)a_{i-1}(x)]f(x) + [b_{i-2}(x) -h_i(x)b_{i-1}(x)]s(x) \\
& = & a_{i-2}(x)f(x) + b_{i-2}(x)s(x) - h_i(x)[a_{i-1}(x)f(x) + b_{i-1}(x)s(x) \\
& = & r_{i-2}(x)-h_i(x)r_{i-1}(x) = r_i(x)
\end{eqnarray*}




completando 1).

De nuevo, cuando $i=0$, 2) se obtiene del paso uno del Algoritmo de Sugiyama. Asumimos que se cumple 2) para $i-1$ veamos que es cierto para $i$,


\begin{eqnarray*}
b_i(x)r_{i-1}(x) - b_{i-1}(x)r_i(x) & = & [b_{i-2}(x) -h_i(x)b_{i-1}(x)]r_{i-1}(x)-b_{i-1}(x)r_i(x) \\
& = & b_{i-2}(x)r_{i-1}(x) - b_{i-1}(x)[h_i(x)r_{i-1}(x) + r_i(x)] \\
& = &  b_{i-2}(x)r_{i-1}(x) - b_{i-1}(x)r_{i-2}(x) \\
& = & -(-1)^{i-1}f(x) = (-1)^if(x)
\end{eqnarray*}



lo que prueba 2).

Cuando $i=0$, 3) se obtiene del paso uno del Algoritmo de Sugiyama y los valores $a_{-1}(x)=1$ y $a_0(x) = 0$. Asumimos que se cumple 3) para $i-1$ veamos que es cierto para $i$,



\[ a_i(x)b_{i-1}(x) - a_{i-1}(x)b_i(x) =
\]
\[ =  [a_{i-2}(x) -h_i(x)a_{i-1}(x)]b_{i-1}(x) - a_{i-1}(x)[b_{i-2}(x) -h_i(x)b_{i-1}(x)] \]

\[ =  -[a_{i-1}(x)b_{i-2}(x) - a_{i-2}(x)b_{i-1}(x)] = -(-1)^i = (-1)^{i+1} \]




lo que prueba 3).

Cuando $i=0$, 4) se obtiene del paso uno del Algoritmo de Sugiyama. Asumimos que se cumple 4) para $i-1$, y veamos que es cierto para $i$, esto es,  $deg(b_{i-1}(x)) + deg(r_{i-2}(x)) = deg(f(x))$. En el paso dos del Algoritmo de Sugiyama, tenemos que $   deg(r_i(x)) < deg(r_{i-2}(x))$. Así que, $deg(b_{i-1}(x)r_i(x)) = deg(b_{i-1}(x) + deg(r_i(x)) < deg(f(x))$ lo que implica 4) para el caso $i$ usando el apartado 2).

\end{proof}

Ahora verificamos que el Algoritmo de Sugiyama funciona. Por el Lema \ref{le:tocho_sugiyama} apartado 1), tenemos, 
\begin{equation}
\label{sugiyama_trece}
a_I(x)x^{2t} + b_I(x)S(x) = r_I(x)
\end{equation}

Por la ecuación clave, también sabemos que,

\begin{equation}
\label{sugiyama_catorce}
a_I(x)x^{2t} + \sigma(x)S(x) = \omega(x)
\end{equation}

para algún polinomio $a(x)$. Multiplicando (\ref{sugiyama_trece}) por $\sigma(x)$ y (\ref{sugiyama_catorce}) por $b_I(x)$ para obtener,

\begin{equation}
\label{sugiyama_quince}
a_I(x)\sigma(x)x^{2t} + b_I(x)\sigma(x)S(x) = r_I(x)\sigma(x)
\end{equation}

y

\begin{equation}
\label{sugiyama_dieciseis}
a_I(x)b_I(x)x^{2t} + \sigma(x)b_I(x)S(x) = \omega(x)b_I(x)
\end{equation}


Módulo $x^{2t}$ implica que 

\begin{equation}
\label{sugiyama_diecisiete}
r_I(x)\sigma(x) \equiv \omega(x)b_I(x) \thinspace (mod \thinspace x^{2t})
\end{equation}


Como $deg(\sigma(x)) \leq t$, por la elección de $I$, $deg(r_I(x)\sigma(x)) = deg(r_I(x)) + deg(\sigma(x)) < t + t = 2t$. Por el Lema \ref{le:tocho_sugiyama} apartado 4), la elección de $I$ y el hecho de que $deg(\omega(x)) < t$, $deg(\omega(x) \times b_I(x)) = deg(\omega(x)) + deg(b_I(x)) = t + (deg(x^{2t}) -deg(r_{I-1}(x)) \leq 3t -t = 2t$. Por eso,(\ref{sugiyama_diecisiete}) implica que $r_I(x)\sigma(x) = \omega(x)b_I(x)$. Esto, junto a (\ref{sugiyama_quince}) y (\ref{sugiyama_dieciseis}), prueba que 


\begin{equation}
\label{sugiyama_dieciocho}
a_I(x)\sigma(x) = a(x)b_I(x)
\end{equation}

Sin embargo, el Lema \ref{le:tocho_sugiyama} apartado 3), implica que $a_I(x)$ y $b_I(x)$ son primos relativos y por tanto, $a(x) = \lambda(x)a_I(x)$ por (\ref{sugiyama_dieciocho}). Sustituyendo esto en (\ref{sugiyama_dieciocho}) tenemos,

\begin{equation}
\label{sugiyama_diecinueve}
\sigma(x) = \lambda(x)b_I(x)
\end{equation}

Si sustituimos esto en (\ref{sugiyama_catorce}), obtenemos $\lambda(x)a_I(x)x^{2t} + \lambda(x)b_I(x)S(x) = \omega(x)$. Luego, (\ref{sugiyama_trece}) implica que

\begin{equation}
\label{sugiyama_veinte}
\omega(x) = \lambda(x)r_I(x)
\end{equation}

Por los Lemas \ref{le:primos_ec_clave}, \ref{sugiyama_diecinueve} y \ref{sugiyama_veinte}, $\lambda(x)$ debe ser una constante no-nula, lo que verifica el paso tres del Algoritmo de Sugiyama.

Como solo nos interesan las raíces de $\sigma(x)$, es suficiente encontrar las raíces de $b_I(x)$ del paso dos, ya que así obtenemos los números de localización de errores.

\begin{exampleth}
\label{ex:algoritmo_sugiyama}

Vamos a obtener un múltiplo escalar del $\sigma(x)$ del Ejemplo \ref{ex:algoritmo_pgz}, usando ahora el Algoritmo de Sugiyama. En el otro ejemplo, teníamos que $t=2$ y los síndromes eran $S_1 = \alpha^2$, $S_2 = \alpha^4$, $S_3 = \alpha^4$ y $S_4 = \alpha^8$.

El Algoritmo de Sugiyama dice que $r_{-1}(x) = x^{2t} = x^4$, $r_0(x) = S(x) = \alpha^8 x^3 + \alpha^4 x^2 + \alpha^4 x + \alpha^2$, $b_{-1}(x)= 0$ y $b_0(x) = 1$. Tenemos que resolver lo siguiente:

$ r_{-1}(x) = r_0(x)h_1(x) + r_1(x)$

$x^4 = (\alpha^8 x^3 + \alpha^4 x^2 + \alpha^4 x + \alpha^2)(\alpha^7 x + \alpha^3) + (\alpha^3 x^2 + \alpha x + \alpha^5)$

$b_1(x) = b_{-1}(x) - h_1(x)b_0(x) = h_1(x) = (\alpha^7 x + \alpha^3)$

Como $deg(r_1(x))$ no es menor que $t$ volvemos a aplicar este paso.

$r_0(x) = r_1(x)h_2(x) + r_2(x)$

$\alpha^8 x^3 + \alpha^4 x^2 + \alpha^4 x + \alpha^2 = (\alpha^3 x^2 + \alpha x + \alpha^5)(\alpha^5 x + \alpha^7) + (\alpha^7 x + \alpha^{14})$

$b_2(x) = b_0(x) - h_2(x)b_1(x)$

$b_2(x) = 1 + (\alpha^5 x + \alpha^7)(\alpha^7 x + \alpha^3) = (\alpha^{12}x^2 + \alpha x + \alpha^5)$


 La siguiente tabla resume los resultados.
 \begin{table}[h]
\begin{tabular}{ c | c | c | c |}
	i & $r_i(x)$ & $h_i(x)$ & $b_i(x)$\\ \hline
	-1 & $x^4$  &  & $0$ \\
	0 & $\alpha^8x^3 + \alpha^{4}x^2+\alpha^4x + \alpha^2$ &  & $1$ \\ 
	1 & $\alpha^3 x^2 + \alpha x + \alpha^{5}$ & $\alpha^7 x + \alpha^{3}$ & $\alpha^7 x + \alpha^{3}$ \\
	2 & $\alpha^7 x + \alpha^{14}$  &  $\alpha^5 x + \alpha^7$ & $\alpha^{12}x^2 + \alpha x + \alpha^5$ 
	\end{tabular}
 \caption{Resumen de los resultados del Algoritmo Extendido de Euclides.}
 \end{table}

Luego, el primer índice $I$ donde $deg(r_I(x)) < t = 2$ es $I = 2$. Por tanto, $\sigma(x)$ es múltiplo de $b_2(x) = \alpha^{12}x^2 + \alpha x + \alpha^5 $.
\end{exampleth}

Podemos concluir con que tanto el Algoritmo de Peterson-Gorenstein-Zierler y el de Sugiyama se pueden usar para decodificar cualquier código cíclico $\mathcal{C}$ hasta la cota BCH. Por supuesto, suponemos que el número de errores es menor que el número de errores que $\mathcal{C}$ es capaz de corregir.%Sea $\mathcal{C}$ un código cíclico con conjunto de definición T y supongamos que T contiene $\delta$ elementos consecutivos $\{ b, b+1, \cdots , b + \delta -2 \}$. Sea $\mathcal{B}$ el código BCH con conjunto de definición $\mathcal{C}_b \cup \mathcal{C}_{b+1} \cup \cdots \cup \mathcal{C}_{b + \delta -2}$, que es un subconjunto de T , luego $\mathcal{C} \subseteq \mathcal{B}$. Sea $t = \lfloor (\delta -1)/2 \rfloor$. Supongamos que transmitimos una palabra código $c(x) \in \mathcal{C}$ y recibimos $y(x)$ donde se han cometido $t$ o menos errores. Entonces $ c(x) \in \mathcal{B}$ y cualquier de los algoritmos que apliquemos a $\mathcal{B}$ corregirá $y(x)$ para obtener $c(x)$. Luego, estos algoritmos corregirán una palabra recibida de cualquier código cíclico si se comenten $v$ errores y $2v+1$ no supera la cota BCH del código. Por supuesto, suponemos que el número de errores es menor que el número de errores que $\mathcal{C}$ es capaz de corregir.